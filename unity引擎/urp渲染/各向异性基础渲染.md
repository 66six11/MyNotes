![](Pasted%20image%2020250327233812.png)
![](Pasted%20image%2020250327233851.png)

各项异性与普通光照模型有些许区别

普通光照渲染：高光通常为圆形

各向异性渲染 ：高光为环形（天使环），并且可以加入扰动变为拉丝形高光

这里以blinn-phong 基于 Kajiya-Kay模型 来实现

> blinn-phong的光照渲染分为： 环境光+漫反射加高光反射
> 
> 这里基于 Kajiya-Kay模型实现为：环境光+漫反射+ 各向异性高光

  

### 核心思路：

  

#### 基础计算

设 ：

> 视线方向V ：点到摄像机
> 
> 光照方向L：点到光源
> 
> 半角向量H = 归一化（V+L）
> 
> 法线N
> 
> 切线T
> 
> 副切线B

  

blinn-phong的高光计算： 光照颜色 * （max（0，H • N ）^ 反光系数

  

各向异性高光计算 ：将 H • N 替换成了 平方根（1- {（T 或者 B）•H }²）

  

即：$$光照颜色\ast max(0, \sqrt{1- (T或者B \ast H)}) ^{反光系数}$$

  

#### 高光扰动：

取一张扰动贴图，例如
![](Pasted%20image%2020250327234107.png)

采样该帖图的同时在T或B方向上加入法向方向的该值 T或者B + N * _采样值（0-1）_ * 扰动程度值

  

计算结果：环境光+漫反射+ 各向异性高光

  

## 源码：（URP渲染管线）

```
Shader "CustomRenderTexture/AnisotropicURP"
{
    Properties
    {
        _Color ("Color", Color) = (1,1,1,1)
        _MainTex("InputTex", 2D) = "white" {}
        _Glossiness("Smoothness", Range(0,1)) = 0.5
        _AnisoTex("Anisotropic Tex", 2D) = "white" {}
        _AnisoOffset("Anisotropic Offset", Range(0,1)) = 0.0
        _AnisoStrength("Anisotropic Strength", Range(0,2)) = 1.0
        _AnisoColor("Anisotropic Color", Color) = (1,1,1,1)
    }

    SubShader
    {
        Tags { "RenderType"="Opaque" "RenderPipeline"="UniversalPipeline" }

        Pass
        {
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"

            struct a2v
            {
                float4 vertex : POSITION;
                float2 uv : TEXCOORD0;
                float4 tangent : TANGENT;
                float3 normal : NORMAL;
            };

            struct v2f
            {
                float4 pos : SV_POSITION;
                float2 uv : TEXCOORD0;
                float3 worldPos : TEXCOORD1;
                float3 tangent : TEXCOORD2;
                float3 normal : TEXCOORD3;
                float3 bitangent : TEXCOORD4;
            };

            TEXTURE2D(_MainTex);
            SAMPLER(sampler_MainTex);
            
            CBUFFER_START(UnityPerMaterial)
                float4 _Color;
                float4 _MainTex_ST;
                float _Glossiness;
                float _AnisoStrength;
                float4 _AnisoColor;
                float _AnisoOffset;
                TEXTURE2D(_AnisoTex);
                SAMPLER(sampler_AnisoTex);
            CBUFFER_END

            v2f vert(a2v v)
            {
                v2f o;
                o.pos = TransformObjectToHClip(v.vertex.xyz);
                o.worldPos = TransformObjectToWorld(v.vertex.xyz);
                o.uv = TRANSFORM_TEX(v.uv, _MainTex);
                
                VertexNormalInputs normalInput = GetVertexNormalInputs(v.normal, v.tangent);
                o.normal = normalInput.normalWS;
                o.tangent = normalInput.tangentWS;
                o.bitangent = normalInput.bitangentWS;
                return o;
            }

            half4 frag(v2f i) : SV_Target
            {
                float aniso = SAMPLE_TEXTURE2D(_AnisoTex, sampler_AnisoTex, i.uv).r;
                // 向量归一化
                float3 N = normalize(i.normal);
                float3 T = normalize(i.tangent + aniso * N * _AnisoOffset);
                float3 B = normalize(i.bitangent + aniso * N * _AnisoOffset);
                float3 V = GetWorldSpaceNormalizeViewDir(i.worldPos);
                
                // 获取主光源数据（含阴影和衰减）
                Light mainLight = GetMainLight();
                float3 L = mainLight.direction;
                float3 ligjtColor = mainLight.color * mainLight.distanceAttenuation * mainLight.shadowAttenuation;
                float3 H = normalize(L + V);
                
                // 基础颜色
                half4 albedo = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv) * _Color;
                
                // 漫反射计算
                float NdotL = saturate(dot(N, L));
                float3 diffuse = ligjtColor* albedo.rgb * NdotL;
                
                // 各向异性高光（Kajiya-Kay模型）
                float dotTH = dot(B, H) ;
                float sinTH = sqrt(saturate(1 - dotTH * dotTH));
                float spec = pow(sinTH, _Glossiness * 128) * _AnisoStrength;
                float3 specular = _AnisoColor.rgb * ligjtColor * spec;
                
                // 环境光（URP标准方法）
                float3 ambient = SampleSH(N) * albedo.rgb;
                
                // 组合结果
                float3 finalColor = diffuse + ambient + specular;
                return half4(finalColor, 1.0);
            }
            ENDHLSL
        }
    }
}

```
